"""
Copyright (C) 2020  Centre for Argument Technology (http://arg.tech)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
 
# Generated from dgdl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextI0


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3X")
        buf.write("\u027b\4\2	\2\4\3	\3\4\4	\4\4\5	\5\4\6	\6\4\7	\7")
        buf.write("\4	\4			\4

\4\13	\13\4\4	\4\16")
        buf.write("	\16\4\17	\17\4\20	\20\4\21	\21\4\22	\22\4\23	\23")
        buf.write("\4\24	\24\4\25	\25\4\26	\26\4\27	\27\4\30	\30\4\31")
        buf.write("	\31\4\32	\32\4\33	\33\4\34	\34\4\35	\35\4\36	\36")
        buf.write("\4\37	\37\4 	 \4!	!\4\"	\"\4#	#\4$	$\4%	%\4&	")
        buf.write("&\4\'	\'\4(	(\4)	)\4*	*\4+	+\4,	,\4-	-\4.	.\4")
        buf.write("/	/\4\60	\60\4\61	\61\4\62	\62\4\63	\63\4\64	\64")
        buf.write("\4\65	\65\4\66	\66\4\67	\67\48	8\49	9\4:	:\4;	")
        buf.write(";\4<	<\4=	=\4>	>\4?	?\4@	@\4A	A\4B	B\4C	C\3\2")
        buf.write("\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\7\2\u0090
\2\2\16")
        buf.write("\2\u0093\13\2\3\2\6\2\u0096
\2\2\16\2\u0097\3\2\3\2")
        buf.write("\3\2\3\3\3\3\3\4\5\4\u00a0
\4\3\4\3\4\6\4\u00a4
\4")
        buf.write("\4\16\4\u00a5\3\4\7\4\u00a9
\4\4\16\4\u00ac\13\4\3")
        buf.write("\4\5\4\u00af
\4\3\4\5\4\u00b2
\4\3\4\7\4\u00b5
\4")
        buf.write("\4\16\4\u00b8\13\4\3\5\3\5\3\5\3\5\3\5\7\5\u00bf
\5")
        buf.write("\5\16\5\u00c2\13\5\3\5\3\5\3\6\3\6\3\6\5\6\u00c9
\6\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\3\3")
        buf.write("\3\3\3\3\5\u00dd
\3\3\3\3\5\u00e3")
        buf.write("
\3\3\3\3\5\u00e9
\3\3\3	\3	\3
")
        buf.write("\3
\3
\3
\3
\3
\7
\u00f5


\16
\u00f8\13
")
        buf.write("\3
\3
\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13")
        buf.write("\u010f
\13\3\13\3\13\3\3\3\3\3\3\3\6")
        buf.write("\u011a
\16\u011b\3\3\5\u0120
\3\16\3")
        buf.write("\16\3\17\3\17\3\20\3\20\3\20\5\20\u0129
\20\3\20\3\20")
        buf.write("\3\20\5\20\u012e
\20\7\20\u0130
\20\20\16\20\u0133")
        buf.write("\13\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\24\3\24\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\27\3\27")
        buf.write("\3\30\3\30\3\31\3\31\5\31\u0158
\31\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\33\3\33")
        buf.write("\3\34\3\34\3\35\3\35\3\35\5\35\u016d
\35\3\35\5\35\u0170")
        buf.write("
\35\3\35\3\35\3\36\6\36\u0175
\36\36\16\36\u0176")
        buf.write("\3\37\3\37\3\37\3\37\3\37\5\37\u017e
\37\3\37\3\37\3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \5 \u018b
 \3 \3 \5 \u018f
")
        buf.write(" \3 \3 \5 \u0193
 \3 \3 \3!\3!\3\"\3\"\3#\3#\3$\3$\3")
        buf.write("$\3%\3%\3%\5%\u01a3
%\3%\3%\3%\7%\u01a8
%%\16%\u01ab")
        buf.write("\13%\3%\3%\3&\3&\3&\3&\3&\3&\3&\3&\3&\3\'\3\'\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3)\3)\3*\3*\5*\u01c5
*\3+\3+\3+\3+\3+\3")
        buf.write("+\3+\3,\3,\3,\3,\3,\3,\3,\3-\3-\3.\3.\3.\3.\3.\3.\3.\3")
        buf.write("/\3/\3/\3/\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60")
        buf.write("\u01ea
\60\3\60\5\60\u01ed
\60\3\60\5\60\u01f0
\60")
        buf.write("\3\61\3\61\3\61\7\61\u01f5
\61\61\16\61\u01f8\13\61")
        buf.write("\3\62\5\62\u01fb
\62\3\62\3\62\3\62\3\62\5\62\u0201
")
        buf.write("\62\3\63\3\63\3\63\3\63\3\63\3\63\3\63\5\63\u020a
\63")
        buf.write("\3\63\3\63\5\63\u020e
\63\3\63\3\63\3\64\3\64\3\65\3")
        buf.write("\65\3\65\5\65\u0217
\65\3\65\3\65\3\65\7\65\u021c
\65")
        buf.write("\65\16\65\u021f\13\65\3\65\3\65\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\3\66\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67")
        buf.write("\3\67\5\67\u0233
\67\3\67\3\67\5\67\u0237
\67\3\67\3")
        buf.write("\67\38\38\39\39\3:\3:\3:\3:\3:\3;\3;\3;\3;\3;\3;\3;\5")
        buf.write(";\u024b
;\3;\5;\u024e
;\3<\3<\3<\3<\3<\3=\3=\3=\3=\3")
        buf.write("=\3=\3=\3=\3=\5=\u025e
=\3=\3=\3=\3=\5=\u0264
=\3=\3")
        buf.write("=\3=\3=\5=\u026a
=\3=\3=\3=\3>\3>\3?\3?\3@\3@\3A\3A\3")
        buf.write("B\3B\3C\3C\3C\2\2D\2\4\6
\16\20\22\24\26\30\32\34")
        buf.write("\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\^`bdfhjln")
        buf.write("prtvxz|~\u0080\u0082\u0084\2\16\3\2QS\3\2TU\3\2\25\26")
        buf.write("\3\2\30\31\3\2NP\3\2!\"\3\2#$\4\2!!&\'\3\2)-\3\2\63\64")
        buf.write("\4\2\30\30\678\5\2\64\6499NN\2\u0270\2\u0086\3\2\2\2\4")
        buf.write("\u009c\3\2\2\2\6\u009f\3\2\2\2\u00b9\3\2\2\2
\u00c8")
        buf.write("\3\2\2\2\u00ca\3\2\2\2\16\u00d5\3\2\2\2\20\u00ec\3\2")
        buf.write("\2\2\22\u00ee\3\2\2\2\24\u00fb\3\2\2\2\26\u0112\3\2\2")
        buf.write("\2\30\u011f\3\2\2\2\32\u0121\3\2\2\2\34\u0123\3\2\2\2")
        buf.write("\36\u0125\3\2\2\2 \u0136\3\2\2\2\"\u013b\3\2\2\2$\u013d")
        buf.write("\3\2\2\2&\u0142\3\2\2\2(\u0144\3\2\2\2*\u014f\3\2\2\2")
        buf.write(",\u0151\3\2\2\2.\u0153\3\2\2\2\60\u0157\3\2\2\2\62\u0159")
        buf.write("\3\2\2\2\64\u0165\3\2\2\2\66\u0167\3\2\2\28\u0169\3\2")
        buf.write("\2\2:\u0174\3\2\2\2<\u017d\3\2\2\2>\u0181\3\2\2\2@\u0196")
        buf.write("\3\2\2\2B\u0198\3\2\2\2D\u019a\3\2\2\2F\u019c\3\2\2\2")
        buf.write("H\u019f\3\2\2\2J\u01ae\3\2\2\2L\u01b7\3\2\2\2N\u01b9\3")
        buf.write("\2\2\2P\u01c0\3\2\2\2R\u01c4\3\2\2\2T\u01c6\3\2\2\2V\u01cd")
        buf.write("\3\2\2\2X\u01d4\3\2\2\2Z\u01d6\3\2\2\2\\u01dd\3\2\2\2")
        buf.write("^\u01e1\3\2\2\2`\u01f1\3\2\2\2b\u01fa\3\2\2\2d\u0202\3")
        buf.write("\2\2\2f\u0211\3\2\2\2h\u0213\3\2\2\2j\u0222\3\2\2\2l\u0229")
        buf.write("\3\2\2\2n\u023a\3\2\2\2p\u023c\3\2\2\2r\u023e\3\2\2\2")
        buf.write("t\u0243\3\2\2\2v\u024f\3\2\2\2x\u0254\3\2\2\2z\u026e\3")
        buf.write("\2\2\2|\u0270\3\2\2\2~\u0272\3\2\2\2\u0080\u0274\3\2\2")
        buf.write("\2\u0082\u0276\3\2\2\2\u0084\u0278\3\2\2\2\u0086\u0087")
        buf.write("\7\3\2\2\u0087\u0088\7\4\2\2\u0088\u0089\7\5\2\2\u0089")
        buf.write("\u008a\7\6\2\2\u008a\u008b\5\4\3\2\u008b\u008c\7\7\2\2")
        buf.write("\u008c\u008d\7\2\2\u008d\u0091\5\6\4\2\u008e\u0090\5")
        buf.write("\62\32\2\u008f\u008e\3\2\2\2\u0090\u0093\3\2\2\2\u0091")
        buf.write("\u008f\3\2\2\2\u0091\u0092\3\2\2\2\u0092\u0095\3\2\2\2")
        buf.write("\u0093\u0091\3\2\2\2\u0094\u0096\5x=\2\u0095\u0094\3\2")
        buf.write("\2\2\u0096\u0097\3\2\2\2\u0097\u0095\3\2\2\2\u0097\u0098")
        buf.write("\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u009a\7	\2\2\u009a")
        buf.write("\u009b\7\2\2\3\u009b\3\3\2\2\2\u009c\u009d\5\u0080A\2")
        buf.write("\u009d\5\3\2\2\2\u009e\u00a0\5\5\2\u009f\u009e\3\2\2")
        buf.write("\2\u009f\u00a0\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u00a3")
        buf.write("\5\7\2\u00a2\u00a4\5\16\2\u00a3\u00a2\3\2\2\2\u00a4")
        buf.write("\u00a5\3\2\2\2\u00a5\u00a3\3\2\2\2\u00a5\u00a6\3\2\2\2")
        buf.write("\u00a6\u00aa\3\2\2\2\u00a7\u00a9\5\24\13\2\u00a8\u00a7")
        buf.write("\3\2\2\2\u00a9\u00ac\3\2\2\2\u00aa\u00a8\3\2\2\2\u00aa")
        buf.write("\u00ab\3\2\2\2\u00ab\u00ae\3\2\2\2\u00ac\u00aa\3\2\2\2")
        buf.write("\u00ad\u00af\5 \21\2\u00ae\u00ad\3\2\2\2\u00ae\u00af\3")
        buf.write("\2\2\2\u00af\u00b1\3\2\2\2\u00b0\u00b2\5$\23\2\u00b1\u00b0")
        buf.write("\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b6\3\2\2\2\u00b3")
        buf.write("\u00b5\5(\25\2\u00b4\u00b3\3\2\2\2\u00b5\u00b8\3\2\2\2")
        buf.write("\u00b6\u00b4\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\7\3\2\2")
        buf.write("\2\u00b8\u00b6\3\2\2\2\u00b9\u00ba\7
\2\2\u00ba\u00bb")
        buf.write("\7\4\2\2\u00bb\u00c0\5
\6\2\u00bc\u00bd\7\13\2\2\u00bd")
        buf.write("\u00bf\5
\6\2\u00be\u00bc\3\2\2\2\u00bf\u00c2\3\2\2\2")
        buf.write("\u00c0\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\u00c3\3")
        buf.write("\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00c4\7\7\2\2\u00c4	")
        buf.write("\3\2\2\2\u00c5\u00c9\7L\2\2\u00c6\u00c9\7M\2\2\u00c7\u00c9")
        buf.write("\5\u0080A\2\u00c8\u00c5\3\2\2\2\u00c8\u00c6\3\2\2\2\u00c8")
        buf.write("\u00c7\3\2\2\2\u00c9\13\3\2\2\2\u00ca\u00cb\7\2\2\u00cb")
        buf.write("\u00cc\7\4\2\2\u00cc\u00cd\7\2\2\u00cd\u00ce\7\6\2\2")
        buf.write("\u00ce\u00cf\5.\30\2\u00cf\u00d0\7\13\2\2\u00d0\u00d1")
        buf.write("\7\16\2\2\u00d1\u00d2\7\6\2\2\u00d2\u00d3\5\60\31\2\u00d3")
        buf.write("\u00d4\7\7\2\2\u00d4\3\2\2\2\u00d5\u00d6\7\17\2\2\u00d6")
        buf.write("\u00d7\7\4\2\2\u00d7\u00d8\7\5\2\2\u00d8\u00d9\7\6\2\2")
        buf.write("\u00d9\u00dc\5\20	\2\u00da\u00db\7\13\2\2\u00db\u00dd")
        buf.write("\5\22
\2\u00dc\u00da\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd")
        buf.write("\u00e2\3\2\2\2\u00de\u00df\7\13\2\2\u00df\u00e0\7\2")
        buf.write("\2\u00e0\u00e1\7\6\2\2\u00e1\u00e3\5.\30\2\u00e2\u00de")
        buf.write("\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e8\3\2\2\2\u00e4")
        buf.write("\u00e5\7\13\2\2\u00e5\u00e6\7\16\2\2\u00e6\u00e7\7\6\2")
        buf.write("\2\u00e7\u00e9\5\60\31\2\u00e8\u00e4\3\2\2\2\u00e8\u00e9")
        buf.write("\3\2\2\2\u00e9\u00ea\3\2\2\2\u00ea\u00eb\7\7\2\2\u00eb")
        buf.write("\17\3\2\2\2\u00ec\u00ed\5\u0080A\2\u00ed\21\3\2\2\2\u00ee")
        buf.write("\u00ef\7
\2\2\u00ef\u00f0\7\6\2\2\u00f0\u00f1\7\2\2")
        buf.write("\u00f1\u00f6\5
\6\2\u00f2\u00f3\7\13\2\2\u00f3\u00f5")
        buf.write("\5
\6\2\u00f4\u00f2\3\2\2\2\u00f5\u00f8\3\2\2\2\u00f6")
        buf.write("\u00f4\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u00f9\3\2\2\2")
        buf.write("\u00f8\u00f6\3\2\2\2\u00f9\u00fa\7	\2\2\u00fa\23\3\2")
        buf.write("\2\2\u00fb\u00fc\7\20\2\2\u00fc\u00fd\7\4\2\2\u00fd\u00fe")
        buf.write("\7\5\2\2\u00fe\u00ff\7\6\2\2\u00ff\u0100\5\26\2\u0100")
        buf.write("\u0101\7\13\2\2\u0101\u0102\7\21\2\2\u0102\u0103\7\6\2")
        buf.write("\2\u0103\u0104\5\30\2\u0104\u0105\7\13\2\2\u0105\u0106")
        buf.write("\7\22\2\2\u0106\u0107\7\6\2\2\u0107\u0108\5\32\16\2\u0108")
        buf.write("\u0109\7\13\2\2\u0109\u010a\7\23\2\2\u010a\u010b\7\6\2")
        buf.write("\2\u010b\u010e\5\34\17\2\u010c\u010d\7\13\2\2\u010d\u010f")
        buf.write("\5\36\20\2\u010e\u010c\3\2\2\2\u010e\u010f\3\2\2\2\u010f")
        buf.write("\u0110\3\2\2\2\u0110\u0111\7\7\2\2\u0111\25\3\2\2\2\u0112")
        buf.write("\u0113\5\u0080A\2\u0113\27\3\2\2\2\u0114\u0120\5\u0080")
        buf.write("A\2\u0115\u0116\7\2\2\u0116\u0119\5\u0080A\2\u0117\u0118")
        buf.write("\7\13\2\2\u0118\u011a\5\u0080A\2\u0119\u0117\3\2\2\2\u011a")
        buf.write("\u011b\3\2\2\2\u011b\u0119\3\2\2\2\u011b\u011c\3\2\2\2")
        buf.write("\u011c\u011d\3\2\2\2\u011d\u011e\7	\2\2\u011e\u0120\3")
        buf.write("\2\2\2\u011f\u0114\3\2\2\2\u011f\u0115\3\2\2\2\u0120\31")
        buf.write("\3\2\2\2\u0121\u0122	\2\2\2\u0122\33\3\2\2\2\u0123\u0124")
        buf.write("	\3\2\2\u0124\35\3\2\2\2\u0125\u0128\7\2\2\u0126\u0129")
        buf.write("\5\u0084C\2\u0127\u0129\7V\2\2\u0128\u0126\3\2\2\2\u0128")
        buf.write("\u0127\3\2\2\2\u0129\u0131\3\2\2\2\u012a\u012d\7\13\2")
        buf.write("\2\u012b\u012e\5\u0084C\2\u012c\u012e\7V\2\2\u012d\u012b")
        buf.write("\3\2\2\2\u012d\u012c\3\2\2\2\u012e\u0130\3\2\2\2\u012f")
        buf.write("\u012a\3\2\2\2\u0130\u0133\3\2\2\2\u0131\u012f\3\2\2\2")
        buf.write("\u0131\u0132\3\2\2\2\u0132\u0134\3\2\2\2\u0133\u0131\3")
        buf.write("\2\2\2\u0134\u0135\7	\2\2\u0135\37\3\2\2\2\u0136\u0137")
        buf.write("\7\24\2\2\u0137\u0138\7\4\2\2\u0138\u0139\5\"\22\2\u0139")
        buf.write("\u013a\7\7\2\2\u013a!\3\2\2\2\u013b\u013c	\4\2\2\u013c")
        buf.write("#\3\2\2\2\u013d\u013e\7\27\2\2\u013e\u013f\7\4\2\2\u013f")
        buf.write("\u0140\5&\24\2\u0140\u0141\7\7\2\2\u0141%\3\2\2\2\u0142")
        buf.write("\u0143	\5\2\2\u0143\'\3\2\2\2\u0144\u0145\7\32\2\2\u0145")
        buf.write("\u0146\7\4\2\2\u0146\u0147\7\5\2\2\u0147\u0148\7\6\2\2")
        buf.write("\u0148\u0149\5,\27\2\u0149\u014a\7\13\2\2\u014a\u014b")
        buf.write("\7\33\2\2\u014b\u014c\7\6\2\2\u014c\u014d\5*\26\2\u014d")
        buf.write("\u014e\7\7\2\2\u014e)\3\2\2\2\u014f\u0150\7V\2\2\u0150")
        buf.write("+\3\2\2\2\u0151\u0152\5\u0080A\2\u0152-\3\2\2\2\u0153")
        buf.write("\u0154\5\u0082B\2\u0154/\3\2\2\2\u0155\u0158\5\u0082B")
        buf.write("\2\u0156\u0158\7\34\2\2\u0157\u0155\3\2\2\2\u0157\u0156")
        buf.write("\3\2\2\2\u0158\61\3\2\2\2\u0159\u015a\7\35\2\2\u015a\u015b")
        buf.write("\7\4\2\2\u015b\u015c\7\5\2\2\u015c\u015d\7\6\2\2\u015d")
        buf.write("\u015e\5\64\33\2\u015e\u015f\7\13\2\2\u015f\u0160\7\36")
        buf.write("\2\2\u0160\u0161\7\6\2\2\u0161\u0162\5\66\34\2\u0162\u0163")
        buf.write("\7\7\2\2\u0163\u0164\58\35\2\u0164\63\3\2\2\2\u0165\u0166")
        buf.write("\5\u0080A\2\u0166\65\3\2\2\2\u0167\u0168	\6\2\2\u0168")
        buf.write("\67\3\2\2\2\u0169\u016f\7\2\2\u016a\u016c\5:\36\2\u016b")
        buf.write("\u016d\5^\60\2\u016c\u016b\3\2\2\2\u016c\u016d\3\2\2\2")
        buf.write("\u016d\u0170\3\2\2\2\u016e\u0170\5^\60\2\u016f\u016a\3")
        buf.write("\2\2\2\u016f\u016e\3\2\2\2\u0170\u0171\3\2\2\2\u0171\u0172")
        buf.write("\7	\2\2\u01729\3\2\2\2\u0173\u0175\5<\37\2\u0174\u0173")
        buf.write("\3\2\2\2\u0175\u0176\3\2\2\2\u0176\u0174\3\2\2\2\u0176")
        buf.write("\u0177\3\2\2\2\u0177;\3\2\2\2\u0178\u017e\5> \2\u0179")
        buf.write("\u017e\5J&\2\u017a\u017e\5N(\2\u017b\u017e\5R*\2\u017c")
        buf.write("\u017e\5Z.\2\u017d\u0178\3\2\2\2\u017d\u0179\3\2\2\2\u017d")
        buf.write("\u017a\3\2\2\2\u017d\u017b\3\2\2\2\u017d\u017c\3\2\2\2")
        buf.write("\u017e\u017f\3\2\2\2\u017f\u0180\7\37\2\2\u0180=\3\2\2")
        buf.write("\2\u0181\u0182\7 \2\2\u0182\u0183\7\4\2\2\u0183\u0184")
        buf.write("\5@!\2\u0184\u0185\7\13\2\2\u0185\u0186\5B\"\2\u0186\u0187")
        buf.write("\7\13\2\2\u0187\u018a\5D#\2\u0188\u0189\7\13\2\2\u0189")
        buf.write("\u018b\5F$\2\u018a\u0188\3\2\2\2\u018a\u018b\3\2\2\2\u018b")
        buf.write("\u018e\3\2\2\2\u018c\u018d\7\13\2\2\u018d\u018f\5H%\2")
        buf.write("\u018e\u018c\3\2\2\2\u018e\u018f\3\2\2\2\u018f\u0192\3")
        buf.write("\2\2\2\u0190\u0191\7\13\2\2\u0191\u0193\5X-\2\u0192\u0190")
        buf.write("\3\2\2\2\u0192\u0193\3\2\2\2\u0193\u0194\3\2\2\2\u0194")
        buf.write("\u0195\7\7\2\2\u0195?\3\2\2\2\u0196\u0197	\7\2\2\u0197")
        buf.write("A\3\2\2\2\u0198\u0199	\2\2\u0199C\3\2\2\2\u019a\u019b")
        buf.write("\5\u0080A\2\u019bE\3\2\2\2\u019c\u019d\7%\2\2\u019d\u019e")
        buf.write("\5\u0080A\2\u019eG\3\2\2\2\u019f\u01a2\7\2\2\u01a0\u01a3")
        buf.write("\5\u0084C\2\u01a1\u01a3\5\/\2\u01a2\u01a0\3\2\2\2\u01a2")
        buf.write("\u01a1\3\2\2\2\u01a3\u01a9\3\2\2\2\u01a4\u01a5\7\13\2")
        buf.write("\2\u01a5\u01a8\5\u0084C\2\u01a6\u01a8\5\/\2\u01a7\u01a4")
        buf.write("\3\2\2\2\u01a7\u01a6\3\2\2\2\u01a8\u01ab\3\2\2\2\u01a9")
        buf.write("\u01a7\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa\u01ac\3\2\2\2")
        buf.write("\u01ab\u01a9\3\2\2\2\u01ac\u01ad\7	\2\2\u01adI\3\2\2")
        buf.write("\2\u01ae\u01af\7\20\2\2\u01af\u01b0\7\4\2\2\u01b0\u01b1")
        buf.write("\5L\'\2\u01b1\u01b2\7\13\2\2\u01b2\u01b3\5\36\20\2\u01b3")
        buf.write("\u01b4\7\13\2\2\u01b4\u01b5\5\26\2\u01b5\u01b6\7\7\2")
        buf.write("\2\u01b6K\3\2\2\2\u01b7\u01b8		\2\2\u01b8M\3\2\2\2\u01b9")
        buf.write("\u01ba\7(\2\2\u01ba\u01bb\7\4\2\2\u01bb\u01bc\5P)\2\u01bc")
        buf.write("\u01bd\7\13\2\2\u01bd\u01be\5\u0080A\2\u01be\u01bf\7\7")
        buf.write("\2\2\u01bfO\3\2\2\2\u01c0\u01c1
\2\2\u01c1Q\3\2\2\2")
        buf.write("\u01c2\u01c5\5T+\2\u01c3\u01c5\5V,\2\u01c4\u01c2\3\2\2")
        buf.write("\2\u01c4\u01c3\3\2\2\2\u01c5S\3\2\2\2\u01c6\u01c7\7.\2")
        buf.write("\2\u01c7\u01c8\7\4\2\2\u01c8\u01c9\5X-\2\u01c9\u01ca\7")
        buf.write("\13\2\2\u01ca\u01cb\5
\6\2\u01cb\u01cc\7\7\2\2\u01cc")
        buf.write("U\3\2\2\2\u01cd\u01ce\7/\2\2\u01ce\u01cf\7\4\2\2\u01cf")
        buf.write("\u01d0\5X-\2\u01d0\u01d1\7\13\2\2\u01d1\u01d2\5
\6\2")
        buf.write("\u01d2\u01d3\7\7\2\2\u01d3W\3\2\2\2\u01d4\u01d5\5\u0080")
        buf.write("A\2\u01d5Y\3\2\2\2\u01d6\u01d7\7\60\2\2\u01d7\u01d8\7")
        buf.write("\4\2\2\u01d8\u01d9\5\36\20\2\u01d9\u01da\7\13\2\2\u01da")
        buf.write("\u01db\5\/\2\u01db\u01dc\7\7\2\2\u01dc[\3\2\2\2\u01dd")
        buf.write("\u01de\7%\2\2\u01de\u01df\5\u0080A\2\u01df\u01e0\7%\2")
        buf.write("\2\u01e0]\3\2\2\2\u01e1\u01e2\7\61\2\2\u01e2\u01e3\7\4")
        buf.write("\2\2\u01e3\u01e4\5`\61\2\u01e4\u01e5\7\7\2\2\u01e5\u01e6")
        buf.write("\7\2\2\u01e6\u01e7\5:\36\2\u01e7\u01e9\7	\2\2\u01e8")
        buf.write("\u01ea\5t;\2\u01e9\u01e8\3\2\2\2\u01e9\u01ea\3\2\2\2\u01ea")
        buf.write("\u01ec\3\2\2\2\u01eb\u01ed\5v<\2\u01ec\u01eb\3\2\2\2\u01ec")
        buf.write("\u01ed\3\2\2\2\u01ed\u01ef\3\2\2\2\u01ee\u01f0\7\37\2")
        buf.write("\2\u01ef\u01ee\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f0_\3\2")
        buf.write("\2\2\u01f1\u01f6\5b\62\2\u01f2\u01f3\7I\2\2\u01f3\u01f5")
        buf.write("\5b\62\2\u01f4\u01f2\3\2\2\2\u01f5\u01f8\3\2\2\2\u01f6")
        buf.write("\u01f4\3\2\2\2\u01f6\u01f7\3\2\2\2\u01f7a\3\2\2\2\u01f8")
        buf.write("\u01f6\3\2\2\2\u01f9\u01fb\7J\2\2\u01fa\u01f9\3\2\2\2")
        buf.write("\u01fa\u01fb\3\2\2\2\u01fb\u0200\3\2\2\2\u01fc\u0201\5")
        buf.write("d\63\2\u01fd\u0201\5j\66\2\u01fe\u0201\5l\67\2\u01ff\u0201")
        buf.write("\5r:\2\u0200\u01fc\3\2\2\2\u0200\u01fd\3\2\2\2\u0200\u01fe")
        buf.write("\3\2\2\2\u0200\u01ff\3\2\2\2\u0201c\3\2\2\2\u0202\u0203")
        buf.write("\7\62\2\2\u0203\u0204\7\4\2\2\u0204\u0205\5f\64\2\u0205")
        buf.write("\u0206\7\13\2\2\u0206\u0209\5D#\2\u0207\u0208\7\13\2\2")
        buf.write("\u0208\u020a\5h\65\2\u0209\u0207\3\2\2\2\u0209\u020a\3")
        buf.write("\2\2\2\u020a\u020d\3\2\2\2\u020b\u020c\7\13\2\2\u020c")
        buf.write("\u020e\5X-\2\u020d\u020b\3\2\2\2\u020d\u020e\3\2\2\2\u020e")
        buf.write("\u020f\3\2\2\2\u020f\u0210\7\7\2\2\u0210e\3\2\2\2\u0211")
        buf.write("\u0212	\13\2\2\u0212g\3\2\2\2\u0213\u0216\7\2\2\u0214")
        buf.write("\u0217\5\/\2\u0215\u0217\7V\2\2\u0216\u0214\3\2\2\2\u0216")
        buf.write("\u0215\3\2\2\2\u0217\u021d\3\2\2\2\u0218\u0219\7\13\2")
        buf.write("\2\u0219\u021c\5\/\2\u021a\u021c\7V\2\2\u021b\u0218\3")
        buf.write("\2\2\2\u021b\u021a\3\2\2\2\u021c\u021f\3\2\2\2\u021d\u021b")
        buf.write("\3\2\2\2\u021d\u021e\3\2\2\2\u021e\u0220\3\2\2\2\u021f")
        buf.write("\u021d\3\2\2\2\u0220\u0221\7	\2\2\u0221i\3\2\2\2\u0222")
        buf.write("\u0223\7\65\2\2\u0223\u0224\7\4\2\2\u0224\u0225\5\20	")
        buf.write("\2\u0225\u0226\7\13\2\2\u0226\u0227\5
\6\2\u0227\u0228")
        buf.write("\7\7\2\2\u0228k\3\2\2\2\u0229\u022a\7\66\2\2\u022a\u022b")
        buf.write("\7\4\2\2\u022b\u022c\5n8\2\u022c\u022d\7\13\2\2\u022d")
        buf.write("\u022e\5\36\20\2\u022e\u022f\7\13\2\2\u022f\u0232\5\26")
        buf.write("\2\u0230\u0231\7\13\2\2\u0231\u0233\5X-\2\u0232\u0230")
        buf.write("\3\2\2\2\u0232\u0233\3\2\2\2\u0233\u0236\3\2\2\2\u0234")
        buf.write("\u0235\7\13\2\2\u0235\u0237\5p9\2\u0236\u0234\3\2\2\2")
        buf.write("\u0236\u0237\3\2\2\2\u0237\u0238\3\2\2\2\u0238\u0239\7")
        buf.write("\7\2\2\u0239m\3\2\2\2\u023a\u023b\2\2\u023bo\3\2\2")
        buf.write("\2\u023c\u023d\2\2\u023dq\3\2\2\2\u023e\u023f\7:\2")
        buf.write("\2\u023f\u0240\7\4\2\2\u0240\u0241\5,\27\2\u0241\u0242")
        buf.write("\7\7\2\2\u0242s\3\2\2\2\u0243\u0244\7;\2\2\u0244\u0245")
        buf.write("\5`\61\2\u0245\u0246\7<\2\2\u0246\u0247\7\2\2\u0247")
        buf.write("\u0248\5:\36\2\u0248\u024a\7	\2\2\u0249\u024b\5t;\2\u024a")
        buf.write("\u0249\3\2\2\2\u024a\u024b\3\2\2\2\u024b\u024d\3\2\2\2")
        buf.write("\u024c\u024e\5v<\2\u024d\u024c\3\2\2\2\u024d\u024e\3\2")
        buf.write("\2\2\u024eu\3\2\2\2\u024f\u0250\7=\2\2\u0250\u0251\7")
        buf.write("\2\2\u0251\u0252\5:\36\2\u0252\u0253\7	\2\2\u0253w\3")
        buf.write("\2\2\2\u0254\u0255\7>\2\2\u0255\u0256\7\4\2\2\u0256\u0257")
        buf.write("\7\5\2\2\u0257\u0258\7\6\2\2\u0258\u025d\5D#\2\u0259\u025a")
        buf.write("\7\13\2\2\u025a\u025b\7?\2\2\u025b\u025c\7\6\2\2\u025c")
        buf.write("\u025e\5X-\2\u025d\u0259\3\2\2\2\u025d\u025e\3\2\2\2\u025e")
        buf.write("\u0263\3\2\2\2\u025f\u0260\7\13\2\2\u0260\u0261\7@\2\2")
        buf.write("\u0261\u0262\7\6\2\2\u0262\u0264\5H%\2\u0263\u025f\3\2")
        buf.write("\2\2\u0263\u0264\3\2\2\2\u0264\u0269\3\2\2\2\u0265\u0266")
        buf.write("\7\13\2\2\u0266\u0267\7A\2\2\u0267\u0268\7\6\2\2\u0268")
        buf.write("\u026a\5z>\2\u0269\u0265\3\2\2\2\u0269\u026a\3\2\2\2\u026a")
        buf.write("\u026b\3\2\2\2\u026b\u026c\7\7\2\2\u026c\u026d\58\35\2")
        buf.write("\u026dy\3\2\2\2\u026e\u026f\7V\2\2\u026f{\3\2\2\2\u0270")
        buf.write("\u0271\7D\2\2\u0271}\3\2\2\2\u0272\u0273\7C\2\2\u0273")
        buf.write("\177\3\2\2\2\u0274\u0275\7B\2\2\u0275\u0081\3\2\2\2\u0276")
        buf.write("\u0277\7E\2\2\u0277\u0083\3\2\2\2\u0278\u0279\7C\2\2\u0279")
        buf.write("\u0085\3\2\2\2\64\u0091\u0097\u009f\u00a5\u00aa\u00ae")
        buf.write("\u00b1\u00b6\u00c0\u00c8\u00dc\u00e2\u00e8\u00f6\u010e")
        buf.write("\u011b\u011f\u0128\u012d\u0131\u0157\u016c\u016f\u0176")
        buf.write("\u017d\u018a\u018e\u0192\u01a2\u01a7\u01a9\u01c4\u01e9")
        buf.write("\u01ec\u01ef\u01f6\u01fa\u0200\u0209\u020d\u0216\u021b")
        buf.write("\u021d\u0232\u0236\u024a\u024d\u025d\u0263\u0269")
        return buf.getvalue()


class dgdlParser ( Parser ):

    grammarFileName = "dgdl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'game'", "'('", "'id'", "':'", "')'",
                     "'{'", "'}'", "'roles'", "','", "'participants'", "'min'",
                     "'max'", "'player'", "'store'", "'owner'", "'structure'",
                     "'visibility'", "'turntaking'", "'strict'", "'liberal'",
                     "'backtracking'", "'on'", "'off'", "'extURI'", "'uri'",
                     "'undefined'", "'rule'", "'scope'", "';'", "'move'",
                     "'add'", "'delete'", "'next'", "'future'", "'$'", "'remove'",
                     "'empty'", "'status'", "'active'", "'inactive'", "'complete'",
                     "'incomplete'", "'terminate'", "'assign'", "'unassign'",
                     "'save'", "'if'", "'event'", "'last'", "'past'", "'inrole'",
                     "'inspect'", "'in'", "'top'", "'current'", "'uriTest'",
                     "'elseif '", "'then'", "'else'", "'interaction'", "'addressee'",
                     "'content'", "'opener'", "<INVALID>", "<INVALID>",
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "<INVALID>", "'&&'", "'!'", "<INVALID>", "'listener'",
                     "'speaker'", "'initial'", "'turnwise'", "'movewise'",
                     "'set'", "'queue'", "'stack'", "'public'", "'private'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "Identifier", "LowerChar", "UpperChar", "Number",
                      "WS", "MOVEACTION", "MOVETIME", "AMPAND", "NEG", "ONOFF",
                      "LISTENER", "SPEAKER", "INITIAL", "TURNWISE", "MOVEWISE",
                      "SET", "QUEUE", "STACK", "PUBLIC", "PRIVATE", "STRINGLITERAL",
                      "COMMENT", "LINE_COMMENT" ]

    RULE_game = 0
    RULE_gameID = 1
    RULE_composition = 2
    RULE_roleList = 3
    RULE_role = 4
    RULE_participants = 5
    RULE_player = 6
    RULE_playerID = 7
    RULE_playerRoleList = 8
    RULE_store = 9
    RULE_storeID = 10
    RULE_storeOwner = 11
    RULE_storeStructure = 12
    RULE_storeVisibility = 13
    RULE_storeContent = 14
    RULE_turntaking = 15
    RULE_turntakingtype = 16
    RULE_backtrack = 17
    RULE_onoff = 18
    RULE_extURI = 19
    RULE_uri = 20
    RULE_extUriID = 21
    RULE_minplayers = 22
    RULE_maxplayers = 23
    RULE_rules = 24
    RULE_ruleID = 25
    RULE_scopeType = 26
    RULE_ruleBody = 27
    RULE_effects = 28
    RULE_effect = 29
    RULE_move = 30
    RULE_moveaction = 31
    RULE_movetime = 32
    RULE_moveID = 33
    RULE_addressee = 34
    RULE_content = 35
    RULE_storeOp = 36
    RULE_storeaction = 37
    RULE_statusUpdate = 38
    RULE_status = 39
    RULE_roleAssignment = 40
    RULE_assignment = 41
    RULE_unassignment = 42
    RULE_user = 43
    RULE_save = 44
    RULE_runtimeVar = 45
    RULE_conditional = 46
    RULE_requirements = 47
    RULE_condition = 48
    RULE_event = 49
    RULE_eventpos = 50
    RULE_eventContent = 51
    RULE_roleInspection = 52
    RULE_storeInspection = 53
    RULE_storepos = 54
    RULE_storetime = 55
    RULE_uriTest = 56
    RULE_condelseif = 57
    RULE_condelse = 58
    RULE_interaction = 59
    RULE_opener = 60
    RULE_upperChar = 61
    RULE_lowerChar = 62
    RULE_identifier = 63
    RULE_number = 64
    RULE_contentVar = 65

    ruleNames =  [ "game", "gameID", "composition", "roleList", "role",
                   "participants", "player", "playerID", "playerRoleList",
                   "store", "storeID", "storeOwner", "storeStructure", "storeVisibility",
                   "storeContent", "turntaking", "turntakingtype", "backtrack",
                   "onoff", "extURI", "uri", "extUriID", "minplayers", "maxplayers",
                   "rules", "ruleID", "scopeType", "ruleBody", "effects",
                   "effect", "move", "moveaction", "movetime", "moveID",
                   "addressee", "content", "storeOp", "storeaction", "statusUpdate",
                   "status", "roleAssignment", "assignment", "unassignment",
                   "user", "save", "runtimeVar", "conditional", "requirements",
                   "condition", "event", "eventpos", "eventContent", "roleInspection",
                   "storeInspection", "storepos", "storetime", "uriTest",
                   "condelseif", "condelse", "interaction", "opener", "upperChar",
                   "lowerChar", "identifier", "number", "contentVar" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    Identifier=64
    LowerChar=65
    UpperChar=66
    Number=67
    WS=68
    MOVEACTION=69
    MOVETIME=70
    AMPAND=71
    NEG=72
    ONOFF=73
    LISTENER=74
    SPEAKER=75
    INITIAL=76
    TURNWISE=77
    MOVEWISE=78
    SET=79
    QUEUE=80
    STACK=81
    PUBLIC=82
    PRIVATE=83
    STRINGLITERAL=84
    COMMENT=85
    LINE_COMMENT=86

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class GameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gameID(self):
            return self.getTypedRuleContext(dgdlParser.GameIDContext,0)


        def composition(self):
            return self.getTypedRuleContext(dgdlParser.CompositionContext,0)


        def EOF(self):
            return self.getToken(dgdlParser.EOF, 0)

        def rules(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RulesContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RulesContext,i)


        def interaction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.InteractionContext)
            else:
                return self.getTypedRuleContext(dgdlParser.InteractionContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_game

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGame" ):
                listener.enterGame(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGame" ):
                listener.exitGame(self)




    def game(self):

        localctx = dgdlParser.GameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_game)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(dgdlParser.T__0)
            self.state = 133
            self.match(dgdlParser.T__1)
            self.state = 134
            self.match(dgdlParser.T__2)
            self.state = 135
            self.match(dgdlParser.T__3)
            self.state = 136
            self.gameID()
            self.state = 137
            self.match(dgdlParser.T__4)
            self.state = 138
            self.match(dgdlParser.T__5)
            self.state = 139
            self.composition()
            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__26:
                self.state = 140
                self.rules()
                self.state = 145
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 146
                self.interaction()
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dgdlParser.T__59):
                    break

            self.state = 151
            self.match(dgdlParser.T__6)
            self.state = 152
            self.match(dgdlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GameIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_gameID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGameID" ):
                listener.enterGameID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGameID" ):
                listener.exitGameID(self)




    def gameID(self):

        localctx = dgdlParser.GameIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_gameID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def participants(self):
            return self.getTypedRuleContext(dgdlParser.ParticipantsContext,0)


        def roleList(self):
            return self.getTypedRuleContext(dgdlParser.RoleListContext,0)


        def player(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.PlayerContext)
            else:
                return self.getTypedRuleContext(dgdlParser.PlayerContext,i)


        def store(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.StoreContext)
            else:
                return self.getTypedRuleContext(dgdlParser.StoreContext,i)


        def turntaking(self):
            return self.getTypedRuleContext(dgdlParser.TurntakingContext,0)


        def backtrack(self):
            return self.getTypedRuleContext(dgdlParser.BacktrackContext,0)


        def extURI(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ExtURIContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ExtURIContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_composition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposition" ):
                listener.enterComposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposition" ):
                listener.exitComposition(self)




    def composition(self):

        localctx = dgdlParser.CompositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_composition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__7:
                self.state = 156
                self.roleList()


            self.state = 159
            self.participants()
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 160
                self.player()
                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dgdlParser.T__12):
                    break

            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__13:
                self.state = 165
                self.store()
                self.state = 170
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__17:
                self.state = 171
                self.turntaking()


            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__20:
                self.state = 174
                self.backtrack()


            self.state = 180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__23:
                self.state = 177
                self.extURI()
                self.state = 182
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RoleContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RoleContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_roleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleList" ):
                listener.enterRoleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleList" ):
                listener.exitRoleList(self)




    def roleList(self):

        localctx = dgdlParser.RoleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_roleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(dgdlParser.T__7)
            self.state = 184
            self.match(dgdlParser.T__1)
            self.state = 185
            self.role()
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__8:
                self.state = 186
                self.match(dgdlParser.T__8)
                self.state = 187
                self.role()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 193
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LISTENER(self):
            return self.getToken(dgdlParser.LISTENER, 0)

        def SPEAKER(self):
            return self.getToken(dgdlParser.SPEAKER, 0)

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)




    def role(self):

        localctx = dgdlParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_role)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.LISTENER]:
                self.state = 195
                self.match(dgdlParser.LISTENER)
                pass
            elif token in [dgdlParser.SPEAKER]:
                self.state = 196
                self.match(dgdlParser.SPEAKER)
                pass
            elif token in [dgdlParser.Identifier]:
                self.state = 197
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minplayers(self):
            return self.getTypedRuleContext(dgdlParser.MinplayersContext,0)


        def maxplayers(self):
            return self.getTypedRuleContext(dgdlParser.MaxplayersContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = dgdlParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_participants)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(dgdlParser.T__9)
            self.state = 201
            self.match(dgdlParser.T__1)
            self.state = 202
            self.match(dgdlParser.T__10)
            self.state = 203
            self.match(dgdlParser.T__3)
            self.state = 204
            self.minplayers()
            self.state = 205
            self.match(dgdlParser.T__8)
            self.state = 206
            self.match(dgdlParser.T__11)
            self.state = 207
            self.match(dgdlParser.T__3)
            self.state = 208
            self.maxplayers()
            self.state = 209
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def playerID(self):
            return self.getTypedRuleContext(dgdlParser.PlayerIDContext,0)


        def playerRoleList(self):
            return self.getTypedRuleContext(dgdlParser.PlayerRoleListContext,0)


        def minplayers(self):
            return self.getTypedRuleContext(dgdlParser.MinplayersContext,0)


        def maxplayers(self):
            return self.getTypedRuleContext(dgdlParser.MaxplayersContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_player

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayer" ):
                listener.enterPlayer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayer" ):
                listener.exitPlayer(self)




    def player(self):

        localctx = dgdlParser.PlayerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_player)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(dgdlParser.T__12)
            self.state = 212
            self.match(dgdlParser.T__1)
            self.state = 213
            self.match(dgdlParser.T__2)
            self.state = 214
            self.match(dgdlParser.T__3)
            self.state = 215
            self.playerID()
            self.state = 218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 216
                self.match(dgdlParser.T__8)
                self.state = 217
                self.playerRoleList()


            self.state = 224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 220
                self.match(dgdlParser.T__8)
                self.state = 221
                self.match(dgdlParser.T__10)
                self.state = 222
                self.match(dgdlParser.T__3)
                self.state = 223
                self.minplayers()


            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 226
                self.match(dgdlParser.T__8)
                self.state = 227
                self.match(dgdlParser.T__11)
                self.state = 228
                self.match(dgdlParser.T__3)
                self.state = 229
                self.maxplayers()


            self.state = 232
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayerIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_playerID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayerID" ):
                listener.enterPlayerID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayerID" ):
                listener.exitPlayerID(self)




    def playerID(self):

        localctx = dgdlParser.PlayerIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_playerID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayerRoleListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RoleContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RoleContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_playerRoleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayerRoleList" ):
                listener.enterPlayerRoleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayerRoleList" ):
                listener.exitPlayerRoleList(self)




    def playerRoleList(self):

        localctx = dgdlParser.PlayerRoleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_playerRoleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(dgdlParser.T__7)
            self.state = 237
            self.match(dgdlParser.T__3)
            self.state = 238
            self.match(dgdlParser.T__5)
            self.state = 239
            self.role()
            self.state = 244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__8:
                self.state = 240
                self.match(dgdlParser.T__8)
                self.state = 241
                self.role()
                self.state = 246
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 247
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeID(self):
            return self.getTypedRuleContext(dgdlParser.StoreIDContext,0)


        def storeOwner(self):
            return self.getTypedRuleContext(dgdlParser.StoreOwnerContext,0)


        def storeStructure(self):
            return self.getTypedRuleContext(dgdlParser.StoreStructureContext,0)


        def storeVisibility(self):
            return self.getTypedRuleContext(dgdlParser.StoreVisibilityContext,0)


        def storeContent(self):
            return self.getTypedRuleContext(dgdlParser.StoreContentContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_store

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStore" ):
                listener.enterStore(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStore" ):
                listener.exitStore(self)




    def store(self):

        localctx = dgdlParser.StoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_store)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(dgdlParser.T__13)
            self.state = 250
            self.match(dgdlParser.T__1)
            self.state = 251
            self.match(dgdlParser.T__2)
            self.state = 252
            self.match(dgdlParser.T__3)
            self.state = 253
            self.storeID()
            self.state = 254
            self.match(dgdlParser.T__8)
            self.state = 255
            self.match(dgdlParser.T__14)
            self.state = 256
            self.match(dgdlParser.T__3)
            self.state = 257
            self.storeOwner()
            self.state = 258
            self.match(dgdlParser.T__8)
            self.state = 259
            self.match(dgdlParser.T__15)
            self.state = 260
            self.match(dgdlParser.T__3)
            self.state = 261
            self.storeStructure()
            self.state = 262
            self.match(dgdlParser.T__8)
            self.state = 263
            self.match(dgdlParser.T__16)
            self.state = 264
            self.match(dgdlParser.T__3)
            self.state = 265
            self.storeVisibility()
            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 266
                self.match(dgdlParser.T__8)
                self.state = 267
                self.storeContent()


            self.state = 270
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_storeID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreID" ):
                listener.enterStoreID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreID" ):
                listener.exitStoreID(self)




    def storeID(self):

        localctx = dgdlParser.StoreIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_storeID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreOwnerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(dgdlParser.IdentifierContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_storeOwner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreOwner" ):
                listener.enterStoreOwner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreOwner" ):
                listener.exitStoreOwner(self)




    def storeOwner(self):

        localctx = dgdlParser.StoreOwnerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_storeOwner)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.Identifier]:
                self.state = 274
                self.identifier()
                pass
            elif token in [dgdlParser.T__5]:
                self.state = 275
                self.match(dgdlParser.T__5)
                self.state = 276
                self.identifier()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 277
                    self.match(dgdlParser.T__8)
                    self.state = 278
                    self.identifier()
                    self.state = 281
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==dgdlParser.T__8):
                        break

                self.state = 283
                self.match(dgdlParser.T__6)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreStructureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(dgdlParser.SET, 0)

        def QUEUE(self):
            return self.getToken(dgdlParser.QUEUE, 0)

        def STACK(self):
            return self.getToken(dgdlParser.STACK, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeStructure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreStructure" ):
                listener.enterStoreStructure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreStructure" ):
                listener.exitStoreStructure(self)




    def storeStructure(self):

        localctx = dgdlParser.StoreStructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_storeStructure)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            _la = self._input.LA(1)
            if not(((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & ((1 << (dgdlParser.SET - 79)) | (1 << (dgdlParser.QUEUE - 79)) | (1 << (dgdlParser.STACK - 79)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreVisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLIC(self):
            return self.getToken(dgdlParser.PUBLIC, 0)

        def PRIVATE(self):
            return self.getToken(dgdlParser.PRIVATE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeVisibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreVisibility" ):
                listener.enterStoreVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreVisibility" ):
                listener.exitStoreVisibility(self)




    def storeVisibility(self):

        localctx = dgdlParser.StoreVisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_storeVisibility)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            _la = self._input.LA(1)
            if not(_la==dgdlParser.PUBLIC or _la==dgdlParser.PRIVATE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreContentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contentVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentVarContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentVarContext,i)


        def STRINGLITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.STRINGLITERAL)
            else:
                return self.getToken(dgdlParser.STRINGLITERAL, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreContent" ):
                listener.enterStoreContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreContent" ):
                listener.exitStoreContent(self)




    def storeContent(self):

        localctx = dgdlParser.StoreContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_storeContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(dgdlParser.T__5)
            self.state = 294
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.LowerChar]:
                self.state = 292
                self.contentVar()
                pass
            elif token in [dgdlParser.STRINGLITERAL]:
                self.state = 293
                self.match(dgdlParser.STRINGLITERAL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__8:
                self.state = 296
                self.match(dgdlParser.T__8)
                self.state = 299
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [dgdlParser.LowerChar]:
                    self.state = 297
                    self.contentVar()
                    pass
                elif token in [dgdlParser.STRINGLITERAL]:
                    self.state = 298
                    self.match(dgdlParser.STRINGLITERAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 305
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 306
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TurntakingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def turntakingtype(self):
            return self.getTypedRuleContext(dgdlParser.TurntakingtypeContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_turntaking

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTurntaking" ):
                listener.enterTurntaking(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTurntaking" ):
                listener.exitTurntaking(self)




    def turntaking(self):

        localctx = dgdlParser.TurntakingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_turntaking)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.match(dgdlParser.T__17)
            self.state = 309
            self.match(dgdlParser.T__1)
            self.state = 310
            self.turntakingtype()
            self.state = 311
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TurntakingtypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_turntakingtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTurntakingtype" ):
                listener.enterTurntakingtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTurntakingtype" ):
                listener.exitTurntakingtype(self)




    def turntakingtype(self):

        localctx = dgdlParser.TurntakingtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_turntakingtype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            _la = self._input.LA(1)
            if not(_la==dgdlParser.T__18 or _la==dgdlParser.T__19):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BacktrackContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onoff(self):
            return self.getTypedRuleContext(dgdlParser.OnoffContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_backtrack

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBacktrack" ):
                listener.enterBacktrack(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBacktrack" ):
                listener.exitBacktrack(self)




    def backtrack(self):

        localctx = dgdlParser.BacktrackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_backtrack)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.match(dgdlParser.T__20)
            self.state = 316
            self.match(dgdlParser.T__1)
            self.state = 317
            self.onoff()
            self.state = 318
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnoffContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_onoff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnoff" ):
                listener.enterOnoff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnoff" ):
                listener.exitOnoff(self)




    def onoff(self):

        localctx = dgdlParser.OnoffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_onoff)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            _la = self._input.LA(1)
            if not(_la==dgdlParser.T__21 or _la==dgdlParser.T__22):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtURIContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def extUriID(self):
            return self.getTypedRuleContext(dgdlParser.ExtUriIDContext,0)


        def uri(self):
            return self.getTypedRuleContext(dgdlParser.UriContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_extURI

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtURI" ):
                listener.enterExtURI(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtURI" ):
                listener.exitExtURI(self)




    def extURI(self):

        localctx = dgdlParser.ExtURIContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_extURI)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(dgdlParser.T__23)
            self.state = 323
            self.match(dgdlParser.T__1)
            self.state = 324
            self.match(dgdlParser.T__2)
            self.state = 325
            self.match(dgdlParser.T__3)
            self.state = 326
            self.extUriID()
            self.state = 327
            self.match(dgdlParser.T__8)
            self.state = 328
            self.match(dgdlParser.T__24)
            self.state = 329
            self.match(dgdlParser.T__3)
            self.state = 330
            self.uri()
            self.state = 331
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UriContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGLITERAL(self):
            return self.getToken(dgdlParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_uri

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUri" ):
                listener.enterUri(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUri" ):
                listener.exitUri(self)




    def uri(self):

        localctx = dgdlParser.UriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_uri)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.match(dgdlParser.STRINGLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtUriIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_extUriID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtUriID" ):
                listener.enterExtUriID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtUriID" ):
                listener.exitExtUriID(self)




    def extUriID(self):

        localctx = dgdlParser.ExtUriIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_extUriID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinplayersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_minplayers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinplayers" ):
                listener.enterMinplayers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinplayers" ):
                listener.exitMinplayers(self)




    def minplayers(self):

        localctx = dgdlParser.MinplayersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_minplayers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 337
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxplayersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_maxplayers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxplayers" ):
                listener.enterMaxplayers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxplayers" ):
                listener.exitMaxplayers(self)




    def maxplayers(self):

        localctx = dgdlParser.MaxplayersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_maxplayers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.Number]:
                self.state = 339
                self.number()
                pass
            elif token in [dgdlParser.T__25]:
                self.state = 340
                self.match(dgdlParser.T__25)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleID(self):
            return self.getTypedRuleContext(dgdlParser.RuleIDContext,0)


        def scopeType(self):
            return self.getTypedRuleContext(dgdlParser.ScopeTypeContext,0)


        def ruleBody(self):
            return self.getTypedRuleContext(dgdlParser.RuleBodyContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_rules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRules" ):
                listener.enterRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRules" ):
                listener.exitRules(self)




    def rules(self):

        localctx = dgdlParser.RulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_rules)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            self.match(dgdlParser.T__26)
            self.state = 344
            self.match(dgdlParser.T__1)
            self.state = 345
            self.match(dgdlParser.T__2)
            self.state = 346
            self.match(dgdlParser.T__3)
            self.state = 347
            self.ruleID()
            self.state = 348
            self.match(dgdlParser.T__8)
            self.state = 349
            self.match(dgdlParser.T__27)
            self.state = 350
            self.match(dgdlParser.T__3)
            self.state = 351
            self.scopeType()
            self.state = 352
            self.match(dgdlParser.T__4)
            self.state = 353
            self.ruleBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_ruleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleID" ):
                listener.enterRuleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleID" ):
                listener.exitRuleID(self)




    def ruleID(self):

        localctx = dgdlParser.RuleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_ruleID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL(self):
            return self.getToken(dgdlParser.INITIAL, 0)

        def TURNWISE(self):
            return self.getToken(dgdlParser.TURNWISE, 0)

        def MOVEWISE(self):
            return self.getToken(dgdlParser.MOVEWISE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_scopeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopeType" ):
                listener.enterScopeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopeType" ):
                listener.exitScopeType(self)




    def scopeType(self):

        localctx = dgdlParser.ScopeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_scopeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            _la = self._input.LA(1)
            if not(((((_la - 76)) & ~0x3f) == 0 and ((1 << (_la - 76)) & ((1 << (dgdlParser.INITIAL - 76)) | (1 << (dgdlParser.TURNWISE - 76)) | (1 << (dgdlParser.MOVEWISE - 76)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def conditional(self):
            return self.getTypedRuleContext(dgdlParser.ConditionalContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_ruleBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBody" ):
                listener.enterRuleBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBody" ):
                listener.exitRuleBody(self)




    def ruleBody(self):

        localctx = dgdlParser.RuleBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ruleBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(dgdlParser.T__5)
            self.state = 365
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.T__13, dgdlParser.T__29, dgdlParser.T__37, dgdlParser.T__43, dgdlParser.T__44, dgdlParser.T__45]:
                self.state = 360
                self.effects()
                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==dgdlParser.T__46:
                    self.state = 361
                    self.conditional()


                pass
            elif token in [dgdlParser.T__46]:
                self.state = 364
                self.conditional()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 367
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effect(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.EffectContext)
            else:
                return self.getTypedRuleContext(dgdlParser.EffectContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_effects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffects" ):
                listener.enterEffects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffects" ):
                listener.exitEffects(self)




    def effects(self):

        localctx = dgdlParser.EffectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_effects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 369
                self.effect()
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dgdlParser.T__13) | (1 << dgdlParser.T__29) | (1 << dgdlParser.T__37) | (1 << dgdlParser.T__43) | (1 << dgdlParser.T__44) | (1 << dgdlParser.T__45))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def move(self):
            return self.getTypedRuleContext(dgdlParser.MoveContext,0)


        def storeOp(self):
            return self.getTypedRuleContext(dgdlParser.StoreOpContext,0)


        def statusUpdate(self):
            return self.getTypedRuleContext(dgdlParser.StatusUpdateContext,0)


        def roleAssignment(self):
            return self.getTypedRuleContext(dgdlParser.RoleAssignmentContext,0)


        def save(self):
            return self.getTypedRuleContext(dgdlParser.SaveContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_effect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffect" ):
                listener.enterEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffect" ):
                listener.exitEffect(self)




    def effect(self):

        localctx = dgdlParser.EffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_effect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.T__29]:
                self.state = 374
                self.move()
                pass
            elif token in [dgdlParser.T__13]:
                self.state = 375
                self.storeOp()
                pass
            elif token in [dgdlParser.T__37]:
                self.state = 376
                self.statusUpdate()
                pass
            elif token in [dgdlParser.T__43, dgdlParser.T__44]:
                self.state = 377
                self.roleAssignment()
                pass
            elif token in [dgdlParser.T__45]:
                self.state = 378
                self.save()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 381
            self.match(dgdlParser.T__28)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def moveaction(self):
            return self.getTypedRuleContext(dgdlParser.MoveactionContext,0)


        def movetime(self):
            return self.getTypedRuleContext(dgdlParser.MovetimeContext,0)


        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def addressee(self):
            return self.getTypedRuleContext(dgdlParser.AddresseeContext,0)


        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_move

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMove" ):
                listener.enterMove(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMove" ):
                listener.exitMove(self)




    def move(self):

        localctx = dgdlParser.MoveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_move)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(dgdlParser.T__29)
            self.state = 384
            self.match(dgdlParser.T__1)
            self.state = 385
            self.moveaction()
            self.state = 386
            self.match(dgdlParser.T__8)
            self.state = 387
            self.movetime()
            self.state = 388
            self.match(dgdlParser.T__8)
            self.state = 389
            self.moveID()
            self.state = 392
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 390
                self.match(dgdlParser.T__8)
                self.state = 391
                self.addressee()


            self.state = 396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 394
                self.match(dgdlParser.T__8)
                self.state = 395
                self.content()


            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 398
                self.match(dgdlParser.T__8)
                self.state = 399
                self.user()


            self.state = 402
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveactionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_moveaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoveaction" ):
                listener.enterMoveaction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoveaction" ):
                listener.exitMoveaction(self)




    def moveaction(self):

        localctx = dgdlParser.MoveactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_moveaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            _la = self._input.LA(1)
            if not(_la==dgdlParser.T__30 or _la==dgdlParser.T__31):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MovetimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_movetime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMovetime" ):
                listener.enterMovetime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMovetime" ):
                listener.exitMovetime(self)




    def movetime(self):

        localctx = dgdlParser.MovetimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_movetime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            _la = self._input.LA(1)
            if not(_la==dgdlParser.T__32 or _la==dgdlParser.T__33):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_moveID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoveID" ):
                listener.enterMoveID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoveID" ):
                listener.exitMoveID(self)




    def moveID(self):

        localctx = dgdlParser.MoveIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_moveID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddresseeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_addressee

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddressee" ):
                listener.enterAddressee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddressee" ):
                listener.exitAddressee(self)




    def addressee(self):

        localctx = dgdlParser.AddresseeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_addressee)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(dgdlParser.T__34)
            self.state = 411
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contentVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentVarContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentVarContext,i)


        def runtimeVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RuntimeVarContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RuntimeVarContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_content

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContent" ):
                listener.enterContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContent" ):
                listener.exitContent(self)




    def content(self):

        localctx = dgdlParser.ContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_content)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(dgdlParser.T__5)
            self.state = 416
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.LowerChar]:
                self.state = 414
                self.contentVar()
                pass
            elif token in [dgdlParser.T__34]:
                self.state = 415
                self.runtimeVar()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 423
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__8 or _la==dgdlParser.T__34:
                self.state = 421
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [dgdlParser.T__8]:
                    self.state = 418
                    self.match(dgdlParser.T__8)
                    self.state = 419
                    self.contentVar()
                    pass
                elif token in [dgdlParser.T__34]:
                    self.state = 420
                    self.runtimeVar()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 426
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreOpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeaction(self):
            return self.getTypedRuleContext(dgdlParser.StoreactionContext,0)


        def storeContent(self):
            return self.getTypedRuleContext(dgdlParser.StoreContentContext,0)


        def storeID(self):
            return self.getTypedRuleContext(dgdlParser.StoreIDContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_storeOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreOp" ):
                listener.enterStoreOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreOp" ):
                listener.exitStoreOp(self)




    def storeOp(self):

        localctx = dgdlParser.StoreOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_storeOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.match(dgdlParser.T__13)
            self.state = 429
            self.match(dgdlParser.T__1)
            self.state = 430
            self.storeaction()
            self.state = 431
            self.match(dgdlParser.T__8)
            self.state = 432
            self.storeContent()
            self.state = 433
            self.match(dgdlParser.T__8)
            self.state = 434
            self.storeID()
            self.state = 435
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreactionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_storeaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreaction" ):
                listener.enterStoreaction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreaction" ):
                listener.exitStoreaction(self)




    def storeaction(self):

        localctx = dgdlParser.StoreactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_storeaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 437
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dgdlParser.T__30) | (1 << dgdlParser.T__35) | (1 << dgdlParser.T__36))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusUpdateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def status(self):
            return self.getTypedRuleContext(dgdlParser.StatusContext,0)


        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_statusUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusUpdate" ):
                listener.enterStatusUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusUpdate" ):
                listener.exitStatusUpdate(self)




    def statusUpdate(self):

        localctx = dgdlParser.StatusUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_statusUpdate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(dgdlParser.T__37)
            self.state = 440
            self.match(dgdlParser.T__1)
            self.state = 441
            self.status()
            self.state = 442
            self.match(dgdlParser.T__8)
            self.state = 443
            self.identifier()
            self.state = 444
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = dgdlParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_status)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dgdlParser.T__38) | (1 << dgdlParser.T__39) | (1 << dgdlParser.T__40) | (1 << dgdlParser.T__41) | (1 << dgdlParser.T__42))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleAssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(dgdlParser.AssignmentContext,0)


        def unassignment(self):
            return self.getTypedRuleContext(dgdlParser.UnassignmentContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_roleAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleAssignment" ):
                listener.enterRoleAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleAssignment" ):
                listener.exitRoleAssignment(self)




    def roleAssignment(self):

        localctx = dgdlParser.RoleAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_roleAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.T__43]:
                self.state = 448
                self.assignment()
                pass
            elif token in [dgdlParser.T__44]:
                self.state = 449
                self.unassignment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)




    def assignment(self):

        localctx = dgdlParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 452
            self.match(dgdlParser.T__43)
            self.state = 453
            self.match(dgdlParser.T__1)
            self.state = 454
            self.user()
            self.state = 455
            self.match(dgdlParser.T__8)
            self.state = 456
            self.role()
            self.state = 457
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnassignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_unassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnassignment" ):
                listener.enterUnassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnassignment" ):
                listener.exitUnassignment(self)




    def unassignment(self):

        localctx = dgdlParser.UnassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_unassignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self.match(dgdlParser.T__44)
            self.state = 460
            self.match(dgdlParser.T__1)
            self.state = 461
            self.user()
            self.state = 462
            self.match(dgdlParser.T__8)
            self.state = 463
            self.role()
            self.state = 464
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_user

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser" ):
                listener.enterUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser" ):
                listener.exitUser(self)




    def user(self):

        localctx = dgdlParser.UserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_user)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SaveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeContent(self):
            return self.getTypedRuleContext(dgdlParser.StoreContentContext,0)


        def runtimeVar(self):
            return self.getTypedRuleContext(dgdlParser.RuntimeVarContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_save

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSave" ):
                listener.enterSave(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSave" ):
                listener.exitSave(self)




    def save(self):

        localctx = dgdlParser.SaveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_save)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self.match(dgdlParser.T__45)
            self.state = 469
            self.match(dgdlParser.T__1)
            self.state = 470
            self.storeContent()
            self.state = 471
            self.match(dgdlParser.T__8)
            self.state = 472
            self.runtimeVar()
            self.state = 473
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuntimeVarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_runtimeVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuntimeVar" ):
                listener.enterRuntimeVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuntimeVar" ):
                listener.exitRuntimeVar(self)




    def runtimeVar(self):

        localctx = dgdlParser.RuntimeVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_runtimeVar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(dgdlParser.T__34)
            self.state = 476
            self.identifier()
            self.state = 477
            self.match(dgdlParser.T__34)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def condelseif(self):
            return self.getTypedRuleContext(dgdlParser.CondelseifContext,0)


        def condelse(self):
            return self.getTypedRuleContext(dgdlParser.CondelseContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional" ):
                listener.enterConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional" ):
                listener.exitConditional(self)




    def conditional(self):

        localctx = dgdlParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_conditional)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(dgdlParser.T__46)
            self.state = 480
            self.match(dgdlParser.T__1)
            self.state = 481
            self.requirements()
            self.state = 482
            self.match(dgdlParser.T__4)
            self.state = 483
            self.match(dgdlParser.T__5)
            self.state = 484
            self.effects()
            self.state = 485
            self.match(dgdlParser.T__6)
            self.state = 487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__56:
                self.state = 486
                self.condelseif()


            self.state = 490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__58:
                self.state = 489
                self.condelse()


            self.state = 493
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__28:
                self.state = 492
                self.match(dgdlParser.T__28)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ConditionContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ConditionContext,i)


        def AMPAND(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.AMPAND)
            else:
                return self.getToken(dgdlParser.AMPAND, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_requirements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirements" ):
                listener.enterRequirements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirements" ):
                listener.exitRequirements(self)




    def requirements(self):

        localctx = dgdlParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            self.condition()
            self.state = 500
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.AMPAND:
                self.state = 496
                self.match(dgdlParser.AMPAND)
                self.state = 497
                self.condition()
                self.state = 502
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def event(self):
            return self.getTypedRuleContext(dgdlParser.EventContext,0)


        def roleInspection(self):
            return self.getTypedRuleContext(dgdlParser.RoleInspectionContext,0)


        def storeInspection(self):
            return self.getTypedRuleContext(dgdlParser.StoreInspectionContext,0)


        def uriTest(self):
            return self.getTypedRuleContext(dgdlParser.UriTestContext,0)


        def NEG(self):
            return self.getToken(dgdlParser.NEG, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = dgdlParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.NEG:
                self.state = 503
                self.match(dgdlParser.NEG)


            self.state = 510
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.T__47]:
                self.state = 506
                self.event()
                pass
            elif token in [dgdlParser.T__50]:
                self.state = 507
                self.roleInspection()
                pass
            elif token in [dgdlParser.T__51]:
                self.state = 508
                self.storeInspection()
                pass
            elif token in [dgdlParser.T__55]:
                self.state = 509
                self.uriTest()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eventpos(self):
            return self.getTypedRuleContext(dgdlParser.EventposContext,0)


        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def eventContent(self):
            return self.getTypedRuleContext(dgdlParser.EventContentContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvent" ):
                listener.enterEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvent" ):
                listener.exitEvent(self)




    def event(self):

        localctx = dgdlParser.EventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_event)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(dgdlParser.T__47)
            self.state = 513
            self.match(dgdlParser.T__1)
            self.state = 514
            self.eventpos()
            self.state = 515
            self.match(dgdlParser.T__8)
            self.state = 516
            self.moveID()
            self.state = 519
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 517
                self.match(dgdlParser.T__8)
                self.state = 518
                self.eventContent()


            self.state = 523
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 521
                self.match(dgdlParser.T__8)
                self.state = 522
                self.user()


            self.state = 525
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventposContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_eventpos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventpos" ):
                listener.enterEventpos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventpos" ):
                listener.exitEventpos(self)




    def eventpos(self):

        localctx = dgdlParser.EventposContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_eventpos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            _la = self._input.LA(1)
            if not(_la==dgdlParser.T__48 or _la==dgdlParser.T__49):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventContentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def runtimeVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RuntimeVarContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RuntimeVarContext,i)


        def STRINGLITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.STRINGLITERAL)
            else:
                return self.getToken(dgdlParser.STRINGLITERAL, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_eventContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventContent" ):
                listener.enterEventContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventContent" ):
                listener.exitEventContent(self)




    def eventContent(self):

        localctx = dgdlParser.EventContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_eventContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.match(dgdlParser.T__5)
            self.state = 532
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dgdlParser.T__34]:
                self.state = 530
                self.runtimeVar()
                pass
            elif token in [dgdlParser.STRINGLITERAL]:
                self.state = 531
                self.match(dgdlParser.STRINGLITERAL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dgdlParser.T__8 or _la==dgdlParser.STRINGLITERAL:
                self.state = 537
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [dgdlParser.T__8]:
                    self.state = 534
                    self.match(dgdlParser.T__8)
                    self.state = 535
                    self.runtimeVar()
                    pass
                elif token in [dgdlParser.STRINGLITERAL]:
                    self.state = 536
                    self.match(dgdlParser.STRINGLITERAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 541
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 542
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleInspectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def playerID(self):
            return self.getTypedRuleContext(dgdlParser.PlayerIDContext,0)


        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_roleInspection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleInspection" ):
                listener.enterRoleInspection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleInspection" ):
                listener.exitRoleInspection(self)




    def roleInspection(self):

        localctx = dgdlParser.RoleInspectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_roleInspection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544
            self.match(dgdlParser.T__50)
            self.state = 545
            self.match(dgdlParser.T__1)
            self.state = 546
            self.playerID()
            self.state = 547
            self.match(dgdlParser.T__8)
            self.state = 548
            self.role()
            self.state = 549
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreInspectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storepos(self):
            return self.getTypedRuleContext(dgdlParser.StoreposContext,0)


        def storeContent(self):
            return self.getTypedRuleContext(dgdlParser.StoreContentContext,0)


        def storeID(self):
            return self.getTypedRuleContext(dgdlParser.StoreIDContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def storetime(self):
            return self.getTypedRuleContext(dgdlParser.StoretimeContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_storeInspection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreInspection" ):
                listener.enterStoreInspection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreInspection" ):
                listener.exitStoreInspection(self)




    def storeInspection(self):

        localctx = dgdlParser.StoreInspectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_storeInspection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(dgdlParser.T__51)
            self.state = 552
            self.match(dgdlParser.T__1)
            self.state = 553
            self.storepos()
            self.state = 554
            self.match(dgdlParser.T__8)
            self.state = 555
            self.storeContent()
            self.state = 556
            self.match(dgdlParser.T__8)
            self.state = 557
            self.storeID()
            self.state = 560
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 558
                self.match(dgdlParser.T__8)
                self.state = 559
                self.user()


            self.state = 564
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 562
                self.match(dgdlParser.T__8)
                self.state = 563
                self.storetime()


            self.state = 566
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreposContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dgdlParser.RULE_storepos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorepos" ):
                listener.enterStorepos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorepos" ):
                listener.exitStorepos(self)




    def storepos(self):

        localctx = dgdlParser.StoreposContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_storepos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dgdlParser.T__21) | (1 << dgdlParser.T__52) | (1 << dgdlParser.T__53))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoretimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL(self):
            return self.getToken(dgdlParser.INITIAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storetime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoretime" ):
                listener.enterStoretime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoretime" ):
                listener.exitStoretime(self)




    def storetime(self):

        localctx = dgdlParser.StoretimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_storetime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 570
            _la = self._input.LA(1)
            if not(((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & ((1 << (dgdlParser.T__49 - 50)) | (1 << (dgdlParser.T__54 - 50)) | (1 << (dgdlParser.INITIAL - 50)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UriTestContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def extUriID(self):
            return self.getTypedRuleContext(dgdlParser.ExtUriIDContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_uriTest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUriTest" ):
                listener.enterUriTest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUriTest" ):
                listener.exitUriTest(self)




    def uriTest(self):

        localctx = dgdlParser.UriTestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_uriTest)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 572
            self.match(dgdlParser.T__55)
            self.state = 573
            self.match(dgdlParser.T__1)
            self.state = 574
            self.extUriID()
            self.state = 575
            self.match(dgdlParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondelseifContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def condelseif(self):
            return self.getTypedRuleContext(dgdlParser.CondelseifContext,0)


        def condelse(self):
            return self.getTypedRuleContext(dgdlParser.CondelseContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_condelseif

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondelseif" ):
                listener.enterCondelseif(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondelseif" ):
                listener.exitCondelseif(self)




    def condelseif(self):

        localctx = dgdlParser.CondelseifContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_condelseif)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 577
            self.match(dgdlParser.T__56)
            self.state = 578
            self.requirements()
            self.state = 579
            self.match(dgdlParser.T__57)
            self.state = 580
            self.match(dgdlParser.T__5)
            self.state = 581
            self.effects()
            self.state = 582
            self.match(dgdlParser.T__6)
            self.state = 584
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__56:
                self.state = 583
                self.condelseif()


            self.state = 587
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 586
                self.condelse()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondelseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_condelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondelse" ):
                listener.enterCondelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondelse" ):
                listener.exitCondelse(self)




    def condelse(self):

        localctx = dgdlParser.CondelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_condelse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self.match(dgdlParser.T__58)
            self.state = 590
            self.match(dgdlParser.T__5)
            self.state = 591
            self.effects()
            self.state = 592
            self.match(dgdlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InteractionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def ruleBody(self):
            return self.getTypedRuleContext(dgdlParser.RuleBodyContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def opener(self):
            return self.getTypedRuleContext(dgdlParser.OpenerContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_interaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteraction" ):
                listener.enterInteraction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteraction" ):
                listener.exitInteraction(self)




    def interaction(self):

        localctx = dgdlParser.InteractionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_interaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594
            self.match(dgdlParser.T__59)
            self.state = 595
            self.match(dgdlParser.T__1)
            self.state = 596
            self.match(dgdlParser.T__2)
            self.state = 597
            self.match(dgdlParser.T__3)
            self.state = 598
            self.moveID()
            self.state = 603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 599
                self.match(dgdlParser.T__8)
                self.state = 600
                self.match(dgdlParser.T__60)
                self.state = 601
                self.match(dgdlParser.T__3)
                self.state = 602
                self.user()


            self.state = 609
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 605
                self.match(dgdlParser.T__8)
                self.state = 606
                self.match(dgdlParser.T__61)
                self.state = 607
                self.match(dgdlParser.T__3)
                self.state = 608
                self.content()


            self.state = 615
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dgdlParser.T__8:
                self.state = 611
                self.match(dgdlParser.T__8)
                self.state = 612
                self.match(dgdlParser.T__62)
                self.state = 613
                self.match(dgdlParser.T__3)
                self.state = 614
                self.opener()


            self.state = 617
            self.match(dgdlParser.T__4)
            self.state = 618
            self.ruleBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpenerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGLITERAL(self):
            return self.getToken(dgdlParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_opener

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpener" ):
                listener.enterOpener(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpener" ):
                listener.exitOpener(self)




    def opener(self):

        localctx = dgdlParser.OpenerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_opener)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 620
            self.match(dgdlParser.STRINGLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpperCharContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UpperChar(self):
            return self.getToken(dgdlParser.UpperChar, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_upperChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpperChar" ):
                listener.enterUpperChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpperChar" ):
                listener.exitUpperChar(self)




    def upperChar(self):

        localctx = dgdlParser.UpperCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_upperChar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(dgdlParser.UpperChar)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LowerCharContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LowerChar(self):
            return self.getToken(dgdlParser.LowerChar, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_lowerChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLowerChar" ):
                listener.enterLowerChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLowerChar" ):
                listener.exitLowerChar(self)




    def lowerChar(self):

        localctx = dgdlParser.LowerCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_lowerChar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.match(dgdlParser.LowerChar)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(dgdlParser.Identifier, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = dgdlParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 626
            self.match(dgdlParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self):
            return self.getToken(dgdlParser.Number, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = dgdlParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self.match(dgdlParser.Number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentVarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LowerChar(self):
            return self.getToken(dgdlParser.LowerChar, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_contentVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContentVar" ):
                listener.enterContentVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContentVar" ):
                listener.exitContentVar(self)




    def contentVar(self):

        localctx = dgdlParser.ContentVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_contentVar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 630
            self.match(dgdlParser.LowerChar)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
